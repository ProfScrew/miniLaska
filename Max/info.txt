Laska
Descrizione del progetto: miniLaska
Laska è una variante del gioco della dama (http://www.lasca.org/)
miniLaska è la variante semplificata che vi proponiamo.
L’obiettivo è di scrivere un programma che implementi una strategia di gioco.
Il progetto sarà organizzato in passi intermedi con sminiLaska è la variante semplificata che vi proponiamo.
L’obiettivo è di scrivere un programma che implementi una strategia di gioco.
Il progetto sarà organizzato in passi intermedi con scadenze suggerite
(rispettare le scadenze significa poterne discutere con il docente)


The pieces
As the game proceeds the following types of piece occur in the game:

SOLDIER: A single counter, plain face uppermost. It can move only diagonally forwards.
When it reaches the opponent’s side of the board, it is promoted to an officer.

OFFICER: A single counter, marked face uppermost.
It can move in either direction, forwards or backwards diagonally.

COLUMN: A stack of two or more soldiers or officers of one colour,
possibly containing prisoners of the opposite colour underneath,
moved as a single piece. The top counter, the commander,
determines who owns and moves the column.

COMMANDER: The top counter of a column.
Only if it is an officer may the column move in either direction.




/*  too complex if the other doesnt work come back to this
  for(i=0; i<7; i++){
    for(j=0; j<7; j++){
      if(Board[i][j][0] == 'w'){
        if(j==0){ /*white pieces on left side
          if(i==5){
            if(Board[i][j][0] == ' '){
              /*can move for promotion
            }
          }else if(Board[i+1][j+1][0]== 'w' || Board[i+1][j+1][0] == 'W'){
            /*cant move
          }else if(Board[i+1][j+1][0] == ' '){
            /*blank space can move here
          }else if(Board[i+1][j+1][0] == 'b' || Board[i+1][j+1][0] == 'B' ){
            if(Board[i+2][j+2][0] ==  ' ' &&  (i+2) == 5){
              /*just one move can eat
            }else if(Board[i+2][i+2][0] == ' '){
              if(left){

              }else if(right){
                if (right){
                  ************
                }else{/*can eat two peaces }
              }
            }

              /*can eat enemy piece

            }
          }
        }else if(j==6){
          if (/* condition ) {
            /* code
          }
        }else{

        }
      }
      if(Board[i][j][0] == 'W'){

      }
    }
  }
*/









void checkBlackMove(char Board[7][7][3]){
  int i, j, a, b, l, m;

  int countEatMove = 1;
  int* eatMove = (int*) malloc (6 * countEatMove * sizeof(int));

  int countNormMoves = 1;
  int*  normalMove = (int*) malloc(4  * countNormMoves * sizeof(int));


  for(i=0; i<7; i++){
    for(j=0; j<7; j++){
      if(Board[i][j][0] == 'b'){
        if(Board[i-1][j-1][0] == ' ' &&  (((i-1) > 0 && (i-1) < 7) && ((j-1) > 0 && (j-1) < 7 ))){
          /*can top bot left*/
          normalMove =  registerMoves(i, j, (i-1), (j-1), normalMove, countNormMoves);
          countNormMoves++;
          normalMove = (int*) realloc(normalMove, 4 *  countNormMoves * sizeof(int));
        }
        if(Board[i-1][j+1][0]== ' ' &&  (((i-1) > 0 && (i-1) < 7) && ((j+1) > 0 && (j+1) < 7 ))){
          /*can top bot right*/
          normalMove = registerMoves(i, j, (i-1), (j+1), normalMove, countNormMoves);
          countNormMoves++;
          normalMove = (int*) realloc(normalMove, 4 * countNormMoves * sizeof(int));
        }
        /*remember to put else */
        /**/

        if(((Board[i-1][j-1][0] == 'w')|| (Board[i-1][j-1][0] == 'W')) &&  (((i-1) > 0 && (i-1) < 7) && ((j-1) > 0 && (j-1) < 7 ))){  /*check bottom left move */
          if(Board[i-2][j-2][0]== ' ' &&  (((i-2) > 0 && (i-2) < 7) && ((j-2) > 0 && (j-2) < 7 ))){
            /*can eat bottom left */
            registerEatMove(i,j,i-2,j-2,i-1,j-1, eatMove, countEatMove);
            countEatMove++;
            eatMove = (int*) realloc(eatMove, 4 * countEatMove * sizeof(int));
          }
        }
        if(((Board[i-1][j+1][0] == 'w')|| (Board[i-1][j+1][0] == 'W')) &&  (((i-1) > 0 && (i-1) < 7) && ((j+1) > 0 && (j+1) < 7 ))){  /*check bottom right move*/
          if(Board[i-2][j+2][0]== ' ' &&  (((i-2) > 0 && (i-2) < 7) && ((j+2) > 0 && (j+2) < 7 ))){
            /*can eat bottom right*/
            registerEatMove(i,j,i-2,j+2,i-1,j+1, eatMove, countEatMove);
            countEatMove++;
            eatMove = (int*) realloc(eatMove, 4 * countEatMove * sizeof(int));
          }
        }



      }
      if(Board[i][j][0] == 'B'){
        /*first part normal moves to blank spot */
        if(Board[i+1][j-1][0] == ' ' &&  (((i+1) > 0 && (i+1) < 7) && ((j-1) > 0 && (j-1) < 7 ))){        /*check bottom left*/
          registerMoves(i, j, (i+1), (j-1), normalMove, countNormMoves);
          countNormMoves++;
          normalMove = (int*) realloc(normalMove, 4 * countNormMoves * sizeof(int));
        }
        if(Board[i+1][j+1][0] == ' ' &&  (((i+1) > 0 && (i+1) < 7) && ((j+1) > 0 && (j+1) < 7 ))){  /*check bottom right*/
          registerMoves(i, j, (i+1), (j+1), normalMove, countNormMoves);
          countNormMoves++;
          normalMove = (int*) realloc(normalMove, 4 * countNormMoves * sizeof(int));
        }
        if(Board[i-1][j-1][0] == ' ' &&  (((i-1) > 0 && (i-1) < 7) && ((j-1) > 0 && (j-1) < 7 ))){  /*check top left*/
          registerMoves(i, j, (i-1), (j-1), normalMove, countNormMoves);
          countNormMoves++;
          normalMove = (int*) realloc(normalMove, 4 * countNormMoves * sizeof(int));
        }
        if(Board[i-1][j+1][0] == ' ' &&  (((i-1) > 0 && (i-1) < 7) && ((j+1) > 0 && (j+1) < 7 ))){  /*check top right*/
          registerMoves(i, j, (i-1), (j+1), normalMove, countNormMoves);
          countNormMoves++;
          normalMove = (int*) realloc(normalMove, 4 * countNormMoves * sizeof(int));
        }



        if(((Board[i+1][j-1][0] == 'w')|| (Board[i+1][j-1][0] == 'W')) &&  (((i+1) > 0 && (i+1) < 7) && ((j-1) > 0 && (j-1) < 7 ))){  /*check bottom left move */
          if(Board[i+2][j-2][0]== ' ' &&  (((i+2) > 0 && (i+2) < 7) && ((j-2) > 0 && (j-2) < 7 ))){
            registerEatMove(i,j,i+2,j-2,i+1,j-1, eatMove, countEatMove);
            countEatMove++;
            eatMove = (int*) realloc(eatMove, 4 * countEatMove * sizeof(int));
          }
        }
        if(((Board[i+1][j+1][0] == 'w')|| (Board[i+1][j+1][0] == 'W')) &&  (((i+1) > 0 && (i+1) < 7) && ((j+1) > 0 && (j+1) < 7 ))){  /*check bottom right move*/
          if(Board[i+2][j+2][0]== ' ' &&  (((i+2) > 0 && (i+2) < 7) && ((j+2) > 0 && (j+2) < 7 ))){
            registerEatMove(i,j,i+2,j+2,i+1,j+1, eatMove, countEatMove);
            countEatMove++;
            eatMove = (int*) realloc(eatMove, 4 * countEatMove * sizeof(int));
          }
        }
        if(((Board[i-1][j-1][0] == 'w')|| (Board[i-1][j-1][0] == 'W')) &&  (((i-1) > 0 && (i-1) < 7) && ((j-1) > 0 && (j-1) < 7 ))){  /*check top left move */
          if(Board[i-2][j-2][0]== ' ' &&  (((i-2) > 0 && (i-2) < 7) && ((j-2) > 0 && (j-2) < 7 ))){
            registerEatMove(i,j,i-2,j-2,i-1,j-1, eatMove, countEatMove);
            countEatMove++;
            eatMove = (int*) realloc(eatMove, 4 * countEatMove * sizeof(int));
          }
        }
        if(((Board[i-1][j+1][0] == 'w')|| (Board[i-1][j+1][0] == 'W')) &&  (((i-1) > 0 && (i-1) < 7) && ((j+1) > 0 && (j+1) < 7 ))){  /*check top left move */
          if(Board[i-2][j+2][0]== ' ' &&  (((i-2) > 0 && (i-2) < 7) && ((j+2) > 0 && (j+2) < 7 ))){
            registerEatMove(i,j,i-2,j+2,i-1,j+1, eatMove, countEatMove);
            countEatMove++;
            eatMove = (int*) realloc(eatMove, 4 * countEatMove * sizeof(int));
          }
        }

      }


    }
  }
  if(((countNormMoves - 1) == 0 )&& ((countEatMove - 1) == 0) ){  /*white player can't do any moves*/
    winner = 'w';
    return;
  }

/*
  printf("normal moves %d\n", countNormMoves );
  for (i = 0; i < ((countNormMoves ) * 4); i++) {
    if(i%4 == 0){
      printf("\n");
    }
    printf("inside ?\n");
    printf("value : %d ", normalMove[i] );

  }
  printf("\nends here.\n");
  free(normalMove);
  free(eatMove);
*/

}
